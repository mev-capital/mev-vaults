{"ast":null,"code":"import BigNumber from 'bignumber.js';\nimport { ethers } from 'ethers';\nimport { contractAddresses } from './lib/constants';\nimport { getContract } from '../utils/erc20';\nimport { DEFAULT_TOKEN_DECIMAL, USDT_TOKEN_DECIMAL, USDT_BSC_TOKEN_DECIMAL, bscUsdtAddress, busdAddress, plgDaiAddress, plgUsdcAddress, plgUsdtAddress } from '../utils/formatbalance';\nimport { log } from '../utils/logger';\nimport { getZunamiAddress, isBSC, isPLG } from '../utils/zunami';\nBigNumber.config({\n  EXPONENTIAL_AT: 1000,\n  DECIMAL_PLACES: 80\n});\nexport const GAS_LIMIT_THRESHOLD = 0.1;\nexport const getMasterChefAddress = sushi => {\n  return sushi && sushi.masterChefAddress;\n};\nexport const getSushiAddress = sushi => {\n  return sushi && sushi.sushiAddress;\n};\nexport const getWethAddress = sushi => {\n  return contractAddresses.weth['1'];\n};\nexport const getUsdcAddress = function () {\n  let chainId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0x1';\n  const chainIdentifier = chainId.split('x')[1];\n  return contractAddresses.usdc[chainIdentifier];\n};\nexport const getWethContract = sushi => {\n  return sushi && sushi.contracts && sushi.contracts.weth;\n};\nexport const getUsdcContract = sushi => {\n  return sushi && sushi.contracts && sushi.contracts.usdc;\n};\nexport const getMasterChefContract = function (sushi) {\n  var _window, _window$ethereum;\n\n  let chain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  const chainId = chain ? chain : (_window = window) === null || _window === void 0 ? void 0 : (_window$ethereum = _window.ethereum) === null || _window$ethereum === void 0 ? void 0 : _window$ethereum.chainId;\n  let result = undefined;\n\n  if (sushi && sushi.contracts) {\n    if (chain === 1 || chainId === '0x1') {\n      // sushi.contracts.masterChef.options.address = getZunamiAddress(chainId);\n      result = sushi.contracts.masterChef;\n    } else if (chain === 56 || chainId === '0x38') {\n      sushi.contracts.bscMasterChef.options.address = getZunamiAddress(chainId);\n      result = sushi.contracts.bscMasterChef;\n    } else if (chain === 137 || chainId === '0x89') {\n      sushi.contracts.polygonContract.options.address = getZunamiAddress(chainId);\n      result = sushi.contracts.polygonContract;\n    }\n  }\n\n  return result;\n};\nexport const getSushiContract = sushi => {\n  return sushi && sushi.contracts && sushi.contracts.sushi;\n};\nexport const getFarms = sushi => {\n  return sushi ? sushi.contracts.pools.map(_ref => {\n    let {\n      pid,\n      name,\n      symbol,\n      icon,\n      tokenAddress,\n      tokenSymbol,\n      tokenContract,\n      lpAddress,\n      lpContract\n    } = _ref;\n    return {\n      pid,\n      id: symbol,\n      name,\n      lpToken: symbol,\n      lpTokenAddress: lpAddress,\n      lpContract,\n      tokenAddress,\n      tokenSymbol,\n      tokenContract,\n      earnToken: 'SUSHI',\n      earnTokenAddress: sushi.contracts.sushi.options.address,\n      icon\n    };\n  }) : [];\n}; // 10M\n\nexport const APPROVE_SUM = '10000000000000000000000000';\nexport const approve = async function (provider, tokenAddress, masterChefContract, account) {\n  var _window$ethereum2, _window$ethereum2$wal;\n\n  let apprSum = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ethers.constants.MaxUint256;\n  const lpContract = getContract(provider, tokenAddress);\n  let sum = apprSum;\n  const isZerionWallet = ((_window$ethereum2 = window.ethereum) === null || _window$ethereum2 === void 0 ? void 0 : (_window$ethereum2$wal = _window$ethereum2.walletMeta) === null || _window$ethereum2$wal === void 0 ? void 0 : _window$ethereum2$wal.name) === 'Zerion';\n\n  if (tokenAddress === bscUsdtAddress || tokenAddress === busdAddress) {\n    sum = APPROVE_SUM;\n  }\n\n  if (tokenAddress === getZunamiAddress(56)) {\n    sum = APPROVE_SUM;\n  }\n\n  if (tokenAddress === contractAddresses.uzd[1]) {\n    sum = APPROVE_SUM;\n  }\n\n  if ([plgDaiAddress, plgUsdcAddress, plgUsdtAddress].indexOf(tokenAddress) !== -1) {\n    sum = APPROVE_SUM;\n  }\n\n  const funcParams = {\n    from: account,\n    maxPriorityFeePerGas: null,\n    maxFeePerGas: null\n  };\n\n  if (isZerionWallet) {\n    const estimate = await lpContract.methods.approve(masterChefContract.options.address, sum).estimateGas();\n    funcParams.gas = Math.floor(estimate + estimate * GAS_LIMIT_THRESHOLD);\n  }\n\n  let spender = masterChefContract.options.address;\n\n  if (tokenAddress === busdAddress) {\n    spender = contractAddresses.busd[56];\n  }\n\n  log(`Executing approve for token ${tokenAddress} for ${sum} sum (spender ${spender})`);\n  return lpContract.methods.approve(spender, sum).send(funcParams).on('transactionHash', tx => {\n    return tx.transactionHash;\n  });\n};\n/**\n * Deposit function\n * @param Contract contract zunamiContract\n * @param string account Wallet address\n * @param {*} lpShares\n * @param {*} dai\n * @param {*} usdc\n * @param {*} usdt\n * @param boolean optimized Whether is should be an optimized deposit (expensive) or not\n * @returns\n */\n\nexport const stake = async function (contract, account, dai, usdc, usdt) {\n  var _window$ethereum3, _window$ethereum3$wal;\n\n  let direct = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let chainId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;\n  const isZerionWallet = ((_window$ethereum3 = window.ethereum) === null || _window$ethereum3 === void 0 ? void 0 : (_window$ethereum3$wal = _window$ethereum3.walletMeta) === null || _window$ethereum3$wal === void 0 ? void 0 : _window$ethereum3$wal.name) === 'Zerion';\n  const coins = [new BigNumber(dai).times(DEFAULT_TOKEN_DECIMAL).toString(), new BigNumber(usdc).times(USDT_TOKEN_DECIMAL).toString(), new BigNumber(usdt).times(USDT_TOKEN_DECIMAL).toString()];\n\n  if (isBSC(chainId)) {\n    return contract.methods.delegateDeposit(new BigNumber(usdt).times(USDT_BSC_TOKEN_DECIMAL).toString()).send({\n      from: account\n    }).on('transactionHash', tx => {\n      return tx.transactionHash;\n    });\n  }\n\n  if (isPLG(chainId)) {\n    log(`Polygon: delegateDeposit(\"${new BigNumber(usdt).times(USDT_TOKEN_DECIMAL).toString()}\")`);\n    return contract.methods.delegateDeposit(new BigNumber(usdt).times(USDT_TOKEN_DECIMAL).toString()).send({\n      from: account,\n      maxPriorityFeePerGas: null,\n      maxFeePerGas: null\n    }).on('transactionHash', tx => {\n      return tx.transactionHash;\n    });\n  }\n\n  log(`Deposit: direct - ${direct}, coins: ${coins}, account: ${account}`);\n  const transactionParams = {\n    from: account\n  };\n\n  if (direct) {\n    log(`Zunami contract: execution deposit(${coins})`);\n\n    if (isZerionWallet) {\n      const estimate = await contract.methods.deposit(coins).estimateGas();\n      transactionParams.gas = Math.floor(estimate + estimate * GAS_LIMIT_THRESHOLD);\n    }\n\n    return contract.methods.deposit(coins).send(transactionParams).on('transactionHash', tx => {\n      return tx.transactionHash;\n    });\n  }\n\n  log(`Zunami contract: execution delegateDeposit(${coins})`);\n\n  if (isZerionWallet) {\n    const estimate = await contract.methods.delegateDeposit(coins).estimateGas();\n    transactionParams.gas = Math.floor(estimate + estimate * GAS_LIMIT_THRESHOLD);\n  }\n\n  return contract.methods.delegateDeposit(coins).send(transactionParams).on('transactionHash', tx => {\n    return tx.transactionHash;\n  });\n};\n/**\n * Stake BUSD\n * @param {*} contract\n * @param {*} account\n * @param {*} busd\n * @returns\n */\n\nexport const stakeBUSD = async (contract, account, busd) => {\n  const depositSum = new BigNumber(busd).times(USDT_BSC_TOKEN_DECIMAL).toString();\n  log(`Exection [ZUN-BUSD]: delegateDepositWithConversion(\"${depositSum}\", \"0\")`);\n  return contract.methods.delegateDepositWithConversion(depositSum, '0').send({\n    from: account\n  }).on('transactionHash', tx => {\n    return tx.transactionHash;\n  });\n};\n/**\n * Withdraw function\n * @param Contract contract zunamiContract\n * @param string account Wallet address\n * @param {*} lpShares\n * @param {*} dai\n * @param {*} usdc\n * @param {*} usdt\n * @param boolean optimized Whether is should be an optimized withdraw (expensive) or not\n * @param number coinIndex Index of coin (0 - DAI, 1 - USDC, 2 - USDT)\n * @returns\n */\n\nexport const unstake = async function (zunamiContract, account, lpShares, dai, usdc, usdt) {\n  let optimized = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n  let coinIndex = arguments.length > 7 ? arguments[7] : undefined;\n  let chainId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;\n  let needsGasEstimation = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;\n  const usdtVal = new BigNumber(usdt).times(USDT_TOKEN_DECIMAL).toString();\n  const coins = [new BigNumber(dai).times(DEFAULT_TOKEN_DECIMAL).toString(), new BigNumber(usdc).times(USDT_TOKEN_DECIMAL).toString(), usdtVal];\n\n  if (optimized) {\n    if (chainId && isBSC(chainId)) {\n      log(`Zunami contract (BNB): execution delegateWithdrawal(${lpShares})`);\n      return zunamiContract.methods.delegateWithdrawal(lpShares).send({\n        from: account\n      }).on('transactionHash', transactionHash => {\n        return transactionHash;\n      });\n    }\n\n    if (chainId && isPLG(chainId)) {\n      log(`Zunami contract (PLG): execution delegateWithdrawal(${lpShares})`);\n      return zunamiContract.methods.delegateWithdrawal(lpShares).send({\n        from: account,\n        maxPriorityFeePerGas: null,\n        maxFeePerGas: null,\n        gasPrice: null\n      }).on('transactionHash', transactionHash => {\n        return transactionHash;\n      });\n    }\n\n    log(`Zunami contract: execution delegateWithdrawal(${lpShares}, ${coins})`);\n    const funcParams = {\n      from: account\n    };\n\n    if (needsGasEstimation) {\n      const estimate = await zunamiContract.methods.delegateWithdrawal(lpShares, coins).estimateGas();\n      funcParams.gas = Math.floor(estimate + estimate * GAS_LIMIT_THRESHOLD);\n    }\n\n    return zunamiContract.methods.delegateWithdrawal(lpShares, coins).send(funcParams).on('transactionHash', transactionHash => {\n      return transactionHash;\n    });\n  } else {\n    log(`Zunami contract: execution withdraw(${lpShares}, [0, 0, 0], 1, ${coinIndex})`);\n    const funcParams = {\n      from: account\n    };\n\n    if (needsGasEstimation) {\n      const estimate = await zunamiContract.methods.withdraw(lpShares, [0, 0, 0], 1, coinIndex).estimateGas();\n      funcParams.gas = Math.floor(estimate + estimate * 0.55);\n    }\n\n    return zunamiContract.methods.withdraw(lpShares, [0, 0, 0], 1, coinIndex).send(funcParams).on('transactionHash', transactionHash => {\n      return transactionHash;\n    });\n  }\n};","map":{"version":3,"names":["BigNumber","ethers","contractAddresses","getContract","DEFAULT_TOKEN_DECIMAL","USDT_TOKEN_DECIMAL","USDT_BSC_TOKEN_DECIMAL","bscUsdtAddress","busdAddress","plgDaiAddress","plgUsdcAddress","plgUsdtAddress","log","getZunamiAddress","isBSC","isPLG","config","EXPONENTIAL_AT","DECIMAL_PLACES","GAS_LIMIT_THRESHOLD","getMasterChefAddress","sushi","masterChefAddress","getSushiAddress","sushiAddress","getWethAddress","weth","getUsdcAddress","chainId","chainIdentifier","split","usdc","getWethContract","contracts","getUsdcContract","getMasterChefContract","chain","window","ethereum","result","undefined","masterChef","bscMasterChef","options","address","polygonContract","getSushiContract","getFarms","pools","map","pid","name","symbol","icon","tokenAddress","tokenSymbol","tokenContract","lpAddress","lpContract","id","lpToken","lpTokenAddress","earnToken","earnTokenAddress","APPROVE_SUM","approve","provider","masterChefContract","account","apprSum","constants","MaxUint256","sum","isZerionWallet","walletMeta","uzd","indexOf","funcParams","from","maxPriorityFeePerGas","maxFeePerGas","estimate","methods","estimateGas","gas","Math","floor","spender","busd","send","on","tx","transactionHash","stake","contract","dai","usdt","direct","coins","times","toString","delegateDeposit","transactionParams","deposit","stakeBUSD","depositSum","delegateDepositWithConversion","unstake","zunamiContract","lpShares","optimized","coinIndex","needsGasEstimation","usdtVal","delegateWithdrawal","gasPrice","withdraw"],"sources":["/home/bacarif/Documents/MEV CAPITAL/ZunamiUI/src/sushi/utils.js"],"sourcesContent":["import BigNumber from 'bignumber.js';\nimport { ethers } from 'ethers';\nimport { contractAddresses } from './lib/constants';\nimport { getContract } from '../utils/erc20';\nimport {\n    DEFAULT_TOKEN_DECIMAL,\n    USDT_TOKEN_DECIMAL,\n    USDT_BSC_TOKEN_DECIMAL,\n    bscUsdtAddress,\n    busdAddress,\n    plgDaiAddress,\n    plgUsdcAddress,\n    plgUsdtAddress,\n} from '../utils/formatbalance';\nimport { log } from '../utils/logger';\nimport { getZunamiAddress, isBSC, isPLG } from '../utils/zunami';\n\nBigNumber.config({\n    EXPONENTIAL_AT: 1000,\n    DECIMAL_PLACES: 80,\n});\n\nexport const GAS_LIMIT_THRESHOLD = 0.1;\n\nexport const getMasterChefAddress = (sushi) => {\n    return sushi && sushi.masterChefAddress;\n};\nexport const getSushiAddress = (sushi) => {\n    return sushi && sushi.sushiAddress;\n};\nexport const getWethAddress = (sushi) => {\n    return contractAddresses.weth['1'];\n};\nexport const getUsdcAddress = (chainId = '0x1') => {\n    const chainIdentifier = chainId.split('x')[1];\n    return contractAddresses.usdc[chainIdentifier];\n};\nexport const getWethContract = (sushi) => {\n    return sushi && sushi.contracts && sushi.contracts.weth;\n};\nexport const getUsdcContract = (sushi) => {\n    return sushi && sushi.contracts && sushi.contracts.usdc;\n};\nexport const getMasterChefContract = (sushi, chain = 1) => {\n    const chainId = chain ? chain : window?.ethereum?.chainId;\n    let result = undefined;\n\n    if (sushi && sushi.contracts) {\n        if (chain === 1 || chainId === '0x1') {\n            // sushi.contracts.masterChef.options.address = getZunamiAddress(chainId);\n            result = sushi.contracts.masterChef;\n        } else if (chain === 56 || chainId === '0x38') {\n            sushi.contracts.bscMasterChef.options.address = getZunamiAddress(chainId);\n            result = sushi.contracts.bscMasterChef;\n        } else if (chain === 137 || chainId === '0x89') {\n            sushi.contracts.polygonContract.options.address = getZunamiAddress(chainId);\n            result = sushi.contracts.polygonContract;\n        }\n    }\n\n    return result;\n};\nexport const getSushiContract = (sushi) => {\n    return sushi && sushi.contracts && sushi.contracts.sushi;\n};\n\nexport const getFarms = (sushi) => {\n    return sushi\n        ? sushi.contracts.pools.map(\n              ({\n                  pid,\n                  name,\n                  symbol,\n                  icon,\n                  tokenAddress,\n                  tokenSymbol,\n                  tokenContract,\n                  lpAddress,\n                  lpContract,\n              }) => ({\n                  pid,\n                  id: symbol,\n                  name,\n                  lpToken: symbol,\n                  lpTokenAddress: lpAddress,\n                  lpContract,\n                  tokenAddress,\n                  tokenSymbol,\n                  tokenContract,\n                  earnToken: 'SUSHI',\n                  earnTokenAddress: sushi.contracts.sushi.options.address,\n                  icon,\n              })\n          )\n        : [];\n};\n\n// 10M\nexport const APPROVE_SUM = '10000000000000000000000000';\n\nexport const approve = async (\n    provider,\n    tokenAddress,\n    masterChefContract,\n    account,\n    apprSum = ethers.constants.MaxUint256\n) => {\n    const lpContract = getContract(provider, tokenAddress);\n    let sum = apprSum;\n    const isZerionWallet = window.ethereum?.walletMeta?.name === 'Zerion';\n\n    if (tokenAddress === bscUsdtAddress || tokenAddress === busdAddress) {\n        sum = APPROVE_SUM;\n    }\n\n    if (tokenAddress === getZunamiAddress(56)) {\n        sum = APPROVE_SUM;\n    }\n\n    if (tokenAddress === contractAddresses.uzd[1]) {\n        sum = APPROVE_SUM;\n    }\n\n    if ([plgDaiAddress, plgUsdcAddress, plgUsdtAddress].indexOf(tokenAddress) !== -1) {\n        sum = APPROVE_SUM;\n    }\n\n    const funcParams = {\n        from: account,\n        maxPriorityFeePerGas: null,\n        maxFeePerGas: null, \n    };\n\n    if (isZerionWallet) {\n        const estimate = await lpContract.methods\n            .approve(masterChefContract.options.address, sum)\n            .estimateGas();\n        funcParams.gas = Math.floor(estimate + estimate * GAS_LIMIT_THRESHOLD);\n    }\n\n    let spender = masterChefContract.options.address;\n\n    if (tokenAddress === busdAddress) {\n        spender = contractAddresses.busd[56];\n    }\n\n    log(`Executing approve for token ${tokenAddress} for ${sum} sum (spender ${spender})`);\n\n    return lpContract.methods\n        .approve(spender, sum)\n        .send(funcParams)\n        .on('transactionHash', (tx) => {\n            return tx.transactionHash;\n        });\n};\n\n/**\n * Deposit function\n * @param Contract contract zunamiContract\n * @param string account Wallet address\n * @param {*} lpShares\n * @param {*} dai\n * @param {*} usdc\n * @param {*} usdt\n * @param boolean optimized Whether is should be an optimized deposit (expensive) or not\n * @returns\n */\nexport const stake = async (contract, account, dai, usdc, usdt, direct = false, chainId = 1) => {\n    const isZerionWallet = window.ethereum?.walletMeta?.name === 'Zerion';\n\n    const coins = [\n        new BigNumber(dai).times(DEFAULT_TOKEN_DECIMAL).toString(),\n        new BigNumber(usdc).times(USDT_TOKEN_DECIMAL).toString(),\n        new BigNumber(usdt).times(USDT_TOKEN_DECIMAL).toString(),\n    ];\n\n    if (isBSC(chainId)) {\n        return contract.methods\n            .delegateDeposit(new BigNumber(usdt).times(USDT_BSC_TOKEN_DECIMAL).toString())\n            .send({ from: account })\n            .on('transactionHash', (tx) => {\n                return tx.transactionHash;\n            });\n    }\n\n    if (isPLG(chainId)) {\n        log(`Polygon: delegateDeposit(\"${new BigNumber(usdt).times(USDT_TOKEN_DECIMAL).toString()}\")`);\n\n        return contract.methods\n            .delegateDeposit(new BigNumber(usdt).times(USDT_TOKEN_DECIMAL).toString())\n            .send({\n                from: account,\n                maxPriorityFeePerGas: null,\n                maxFeePerGas: null, \n            })\n            .on('transactionHash', (tx) => {\n                return tx.transactionHash;\n            });\n    }\n\n    log(`Deposit: direct - ${direct}, coins: ${coins}, account: ${account}`);\n\n    const transactionParams = {\n        from: account,\n    }\n\n    if (direct) {\n        log(`Zunami contract: execution deposit(${coins})`);\n\n        if (isZerionWallet) {\n            const estimate = await contract.methods.deposit(coins).estimateGas();\n            transactionParams.gas = Math.floor(estimate + estimate * GAS_LIMIT_THRESHOLD);\n        }\n\n        return contract.methods\n            .deposit(coins)\n            .send(transactionParams)\n            .on('transactionHash', (tx) => {\n                return tx.transactionHash;\n            });\n    }\n\n    log(`Zunami contract: execution delegateDeposit(${coins})`);\n\n    if (isZerionWallet) {\n        const estimate = await contract.methods.delegateDeposit(coins).estimateGas();\n        transactionParams.gas = Math.floor(estimate + estimate * GAS_LIMIT_THRESHOLD);\n    }\n\n    return contract.methods\n        .delegateDeposit(coins)\n        .send(transactionParams)\n        .on('transactionHash', (tx) => {\n            return tx.transactionHash;\n        });\n};\n\n/**\n * Stake BUSD\n * @param {*} contract\n * @param {*} account\n * @param {*} busd\n * @returns\n */\nexport const stakeBUSD = async (contract, account, busd) => {\n    const depositSum = new BigNumber(busd).times(USDT_BSC_TOKEN_DECIMAL).toString();\n\n    log(`Exection [ZUN-BUSD]: delegateDepositWithConversion(\"${depositSum}\", \"0\")`);\n\n    return contract.methods\n        .delegateDepositWithConversion(depositSum, '0')\n        .send({ from: account })\n        .on('transactionHash', (tx) => {\n            return tx.transactionHash;\n        });\n};\n\n/**\n * Withdraw function\n * @param Contract contract zunamiContract\n * @param string account Wallet address\n * @param {*} lpShares\n * @param {*} dai\n * @param {*} usdc\n * @param {*} usdt\n * @param boolean optimized Whether is should be an optimized withdraw (expensive) or not\n * @param number coinIndex Index of coin (0 - DAI, 1 - USDC, 2 - USDT)\n * @returns\n */\nexport const unstake = async (\n    zunamiContract,\n    account,\n    lpShares,\n    dai,\n    usdc,\n    usdt,\n    optimized = true,\n    coinIndex,\n    chainId = 1,\n    needsGasEstimation = false\n) => {\n    const usdtVal = new BigNumber(usdt).times(USDT_TOKEN_DECIMAL).toString();\n    const coins = [\n        new BigNumber(dai).times(DEFAULT_TOKEN_DECIMAL).toString(),\n        new BigNumber(usdc).times(USDT_TOKEN_DECIMAL).toString(),\n        usdtVal,\n    ];\n\n    if (optimized) {\n        if (chainId && isBSC(chainId)) {\n            log(`Zunami contract (BNB): execution delegateWithdrawal(${lpShares})`);\n\n            return zunamiContract.methods\n                .delegateWithdrawal(lpShares)\n                .send({ from: account })\n                .on('transactionHash', (transactionHash) => {\n                    return transactionHash;\n                });\n        }\n\n        if (chainId && isPLG(chainId)) {\n            log(`Zunami contract (PLG): execution delegateWithdrawal(${lpShares})`);\n\n            return zunamiContract.methods\n                .delegateWithdrawal(lpShares)\n                .send({\n                    from: account,\n                    maxPriorityFeePerGas: null,\n                    maxFeePerGas: null,\n                    gasPrice: null,\n                })\n                .on('transactionHash', (transactionHash) => {\n                    return transactionHash;\n                });\n        }\n\n        log(`Zunami contract: execution delegateWithdrawal(${lpShares}, ${coins})`);\n\n        const funcParams = { from: account };\n\n        if (needsGasEstimation) {\n            const estimate = await zunamiContract.methods\n                .delegateWithdrawal(lpShares, coins)\n                .estimateGas();\n            funcParams.gas = Math.floor(estimate + estimate * GAS_LIMIT_THRESHOLD);\n        }\n\n        return zunamiContract.methods\n            .delegateWithdrawal(lpShares, coins)\n            .send(funcParams)\n            .on('transactionHash', (transactionHash) => {\n                return transactionHash;\n            });\n    } else {\n        log(`Zunami contract: execution withdraw(${lpShares}, [0, 0, 0], 1, ${coinIndex})`);\n        const funcParams = { from: account };\n\n        if (needsGasEstimation) {\n            const estimate = await zunamiContract.methods\n                .withdraw(lpShares, [0, 0, 0], 1, coinIndex)\n                .estimateGas();\n            funcParams.gas = Math.floor(estimate + estimate * 0.55);\n        }\n\n        return zunamiContract.methods\n            .withdraw(lpShares, [0, 0, 0], 1, coinIndex)\n            .send(funcParams)\n            .on('transactionHash', (transactionHash) => {\n                return transactionHash;\n            });\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}