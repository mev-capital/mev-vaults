{"ast":null,"code":"import Web3 from 'web3';\nimport ERC20 from '../actions/abi/erc20.abi.json';\nimport { log } from '../utils/logger';\nexport const getContract = (provider, address) => {\n  const web3 = new Web3(provider);\n  const contract = new web3.eth.Contract(ERC20, address);\n  return contract;\n};\nexport const getAllowance = async (provider, tokenAddress, masterChefContract, account) => {\n  const lpContract = getContract(provider, tokenAddress);\n\n  try {\n    const allowance = await lpContract.methods.allowance(account, masterChefContract.options.address).call();\n    log(`Allowance for ${tokenAddress}: ${allowance}`);\n    return allowance;\n  } catch (e) {\n    return '0';\n  }\n};\n/**\n * Calculates how many coins user will get in exchange to lp tokens\n * @param zunamiContract contract\n * @param lpBalance string Balance in LP tokens\n * @param coinIndex number Coin index (0 - DAI, 1 - USDC, 2 - USDT)\n * @returns string\n */\n\nexport const calcWithdrawOneCoin = async (lpBalance, coinIndex, account) => {\n  const contract = sushi.getEthContract();\n  contract.options.from = account;\n  log(`ETH contract (${contract.options.address}) - calcWithdrawOneCoin(${lpBalance}, ${coinIndex}).`);\n  let sum = \"Error\";\n\n  try {\n    sum = await contract.methods.calcWithdrawOneCoin(lpBalance, coinIndex).call();\n  } catch {\n    const whaleWalletAccount = \"0xc288540f761179dfcf5e64514282463515839df4\";\n    contract.options.from = whaleWalletAccount;\n    sum = await contract.methods.calcWithdrawOneCoin(lpBalance, coinIndex).call();\n  }\n\n  log(`ETH contract (${contract.options.address}) - calcWithdrawOneCoin result ${sum}`);\n  return sum;\n};\nexport const getBalance = async (provider, tokenAddress, userAddress) => {\n  const lpContract = getContract(provider, tokenAddress);\n\n  try {\n    const balance = await lpContract.methods.balanceOf(userAddress).call();\n    return balance;\n  } catch (e) {\n    return '0';\n  }\n};\nexport const getLpPrice = async masterChefContract => {\n  return await masterChefContract.methods.lpPrice().call();\n};\nexport const getUserLpAmount = async (masterChefContract, userAddress) => {\n  try {\n    const lpAmount = await masterChefContract.methods.balanceOf(userAddress).call();\n    return lpAmount;\n  } catch (e) {\n    return '0';\n  }\n};","map":{"version":3,"names":["Web3","ERC20","log","getContract","provider","address","web3","contract","eth","Contract","getAllowance","tokenAddress","masterChefContract","account","lpContract","allowance","methods","options","call","e","calcWithdrawOneCoin","lpBalance","coinIndex","sushi","getEthContract","from","sum","whaleWalletAccount","getBalance","userAddress","balance","balanceOf","getLpPrice","lpPrice","getUserLpAmount","lpAmount"],"sources":["/home/bacarif/Documents/MEV CAPITAL/ZunamiUI/src/utils/erc20.ts"],"sourcesContent":["import Web3 from 'web3';\nimport { provider as Provider } from 'web3-core';\nimport { Contract } from 'web3-eth-contract';\nimport { AbiItem } from 'web3-utils';\nimport ERC20 from '../actions/abi/erc20.abi.json';\nimport { log } from '../utils/logger';\n\nexport const getContract = (provider: Provider, address: string) => {\n    const web3 = new Web3(provider);\n    const contract = new web3.eth.Contract(ERC20 as unknown as AbiItem, address);\n    return contract;\n};\n\nexport const getAllowance = async (\n    provider: Provider,\n    tokenAddress: string,\n    masterChefContract: Contract,\n    account: string\n): Promise<string> => {\n    const lpContract = getContract(provider, tokenAddress);\n    try {\n        const allowance: string = await lpContract.methods\n            .allowance(account, masterChefContract.options.address)\n            .call();\n\n        log(`Allowance for ${tokenAddress}: ${allowance}`);\n        return allowance;\n    } catch (e) {\n        return '0';\n    }\n};\n\n/**\n * Calculates how many coins user will get in exchange to lp tokens\n * @param zunamiContract contract\n * @param lpBalance string Balance in LP tokens\n * @param coinIndex number Coin index (0 - DAI, 1 - USDC, 2 - USDT)\n * @returns string\n */\nexport const calcWithdrawOneCoin = async (\n    lpBalance: string,\n    coinIndex: number,\n    account: string | null\n): Promise<string> => {\n    const contract = sushi.getEthContract();\n    contract.options.from = account;\n    log(`ETH contract (${contract.options.address}) - calcWithdrawOneCoin(${lpBalance}, ${coinIndex}).`);\n    let sum: string = \"Error\";\n    try {\n        sum = await contract.methods.calcWithdrawOneCoin(lpBalance, coinIndex).call();\n    } catch {\n        const whaleWalletAccount = \"0xc288540f761179dfcf5e64514282463515839df4\";\n        contract.options.from = whaleWalletAccount;\n        sum = await contract.methods.calcWithdrawOneCoin(lpBalance, coinIndex).call();\n    }\n    log(`ETH contract (${contract.options.address}) - calcWithdrawOneCoin result ${sum}`);\n    return sum;\n};\n\nexport const getBalance = async (\n    provider: Provider,\n    tokenAddress: string,\n    userAddress: string\n): Promise<string> => {\n    const lpContract = getContract(provider, tokenAddress);\n    try {\n        const balance: string = await lpContract.methods.balanceOf(userAddress).call();\n        return balance;\n    } catch (e) {\n        return '0';\n    }\n};\n\nexport const getLpPrice = async (masterChefContract: Contract): Promise<string> => {\n    return await masterChefContract.methods.lpPrice().call();\n};\n\nexport const getUserLpAmount = async (\n    masterChefContract: Contract,\n    userAddress: string\n): Promise<string> => {\n    try {\n        const lpAmount: string = await masterChefContract.methods.balanceOf(userAddress).call();\n        return lpAmount;\n    } catch (e) {\n        return '0';\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}